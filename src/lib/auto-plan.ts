import {
  AutoPlanSettings,
  CapacityUsage,
  PlannedTask,
  PRIORITY_WEIGHTS,
  Status,
  TaskPart,
} from "@/types";

export interface AutoPlanResult {
  tasks: PlannedTask[];
  capacityUsage: Record<string, CapacityUsage>;
}

export const DEFAULT_AUTOPLAN_SETTINGS: AutoPlanSettings = {
  dailyCapacityMinutes: 240,
  minChunkMinutes: 30,
  planningHorizonDays: 14,
};

const startOfDay = (input: Date): Date => {
  const result = new Date(input);
  result.setHours(0, 0, 0, 0);
  return result;
};

const toDate = (value: string | Date): Date => {
  if (value instanceof Date) {
    return new Date(value.getTime());
  }

  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    const [year, month, day] = value.split("-").map(Number);
    if (year && month && day) {
      return new Date(year, month - 1, day);
    }
  }

  return parsed;
};

const addDays = (date: Date, amount: number): Date => {
  const result = new Date(date);
  result.setDate(result.getDate() + amount);
  return result;
};

const formatDayKey = (date: Date): string => {
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const parseDayKey = (key: string): Date => {
  const [year, month, day] = key.split("-").map(Number);
  if (!Number.isNaN(year) && !Number.isNaN(month) && !Number.isNaN(day)) {
    return startOfDay(new Date(year, month - 1, day));
  }
  return startOfDay(new Date(key));
};

const getCapacityForDate = (settings: AutoPlanSettings, date: Date): number => {
  const dayKey = formatDayKey(date);
  const overrideByDate = settings.capacityOverrides?.[dayKey];
  if (overrideByDate !== undefined) {
    return Math.max(0, overrideByDate);
  }

  const weekdayOverride = settings.weekdayCapacities?.[date.getDay()];
  if (weekdayOverride !== undefined) {
    return Math.max(0, weekdayOverride);
  }

  return Math.max(0, settings.dailyCapacityMinutes);
};

const cloneTask = (task: PlannedTask): PlannedTask => ({
  ...task,
  parts: task.parts?.map((part) => ({ ...part })) ?? [],
});

const scheduleOrderComparator = (left: PlannedTask, right: PlannedTask): number => {
  const leftPriority = PRIORITY_WEIGHTS[left.priority] ?? 0;
  const rightPriority = PRIORITY_WEIGHTS[right.priority] ?? 0;
  if (leftPriority !== rightPriority) {
    return rightPriority - leftPriority;
  }

  const leftDue = left.dueDate ? startOfDay(toDate(left.dueDate)).getTime() : Number.POSITIVE_INFINITY;
  const rightDue = right.dueDate ? startOfDay(toDate(right.dueDate)).getTime() : Number.POSITIVE_INFINITY;
  if (leftDue !== rightDue) {
    return leftDue - rightDue;
  }

  const leftDuration = left.durationMinutes ?? 0;
  const rightDuration = right.durationMinutes ?? 0;
  if (leftDuration !== rightDuration) {
    return rightDuration - leftDuration;
  }

  return left.title.localeCompare(right.title);
};

const isSchedulable = (task: PlannedTask): boolean =>
  task.status === Status.BACKLOG || task.status === Status.ACTIVE;

const clampRemaining = (value: number): number => (value < 0 ? 0 : value);

const normalizeParts = (parts: TaskPart[] | undefined): TaskPart[] => {
  if (!parts?.length) {
    return [];
  }

  const manualParts = parts.filter((part) => !part.isAutoGenerated);
  if (!manualParts.length) {
    return [];
  }

  return manualParts
    .slice()
    .sort((a, b) => a.sequence - b.sequence)
    .map((part, index) => ({
      ...part,
      sequence: index,
      plannedDate: formatDayKey(startOfDay(toDate(part.plannedDate))),
      isAutoGenerated: false,
    }));
};

const ensureDayEntry = (
  usage: Record<string, CapacityUsage>,
  settings: AutoPlanSettings,
  dayKey: string,
): CapacityUsage => {
  if (!usage[dayKey]) {
    const date = parseDayKey(dayKey);
    const total = getCapacityForDate(settings, date);
    usage[dayKey] = {
      total,
      used: 0,
      remaining: total,
    };
  }

  return usage[dayKey];
};

const findEarliestPartDate = (parts: TaskPart[]): string | null => {
  if (!parts.length) {
    return null;
  }

  return parts
    .slice()
    .sort((a, b) => a.plannedDate.localeCompare(b.plannedDate) || a.sequence - b.sequence)[0]
    .plannedDate;
};

const MIN_ITERATION_BUFFER = 120;

export const autoPlan = (
  tasks: PlannedTask[],
  settings: AutoPlanSettings,
  referenceToday: Date,
): AutoPlanResult => {
  const sanitizedTasks = tasks.map(cloneTask).map((task) => {
    const normalized: PlannedTask = {
      ...task,
      parts: normalizeParts(task.parts),
    };

    if (normalized.pinnedDate) {
      const pinnedDay = startOfDay(toDate(normalized.pinnedDate));
      if (pinnedDay < startOfDay(referenceToday)) {
        normalized.pinnedDate = null;
      } else {
        normalized.pinnedDate = formatDayKey(pinnedDay);
      }
    }

    if (normalized.plannedDate) {
      normalized.plannedDate = formatDayKey(startOfDay(toDate(normalized.plannedDate)));
    }

    return normalized;
  });

  const today = startOfDay(referenceToday);
  const horizonDays = Math.max(1, settings.planningHorizonDays);
  const horizonEnd = addDays(today, horizonDays - 1);
  const usage: Record<string, CapacityUsage> = {};
  const manualMinutes = new Map<string, number>();

  sanitizedTasks.forEach((task) => {
    const manualParts = task.parts ?? [];
    const totalManual = manualParts.reduce((total, part) => total + part.durationMinutes, 0);
    manualMinutes.set(task.id, totalManual);

    manualParts.forEach((part) => {
      const entry = ensureDayEntry(usage, settings, part.plannedDate);
      entry.used += part.durationMinutes;
      entry.remaining = Math.max(0, entry.total - entry.used);
    });
  });

  const outstandingTasks = sanitizedTasks.filter((task) => {
    if (!isSchedulable(task)) {
      return false;
    }

    const remaining = clampRemaining((task.durationMinutes ?? 0) - (manualMinutes.get(task.id) ?? 0));
    return remaining > 0;
  });

  const pinnedTasks = outstandingTasks
    .filter((task) => Boolean(task.pinnedDate))
    .sort((a, b) => {
      if (a.pinnedDate && b.pinnedDate && a.pinnedDate !== b.pinnedDate) {
        return a.pinnedDate.localeCompare(b.pinnedDate);
      }
      return scheduleOrderComparator(a, b);
    });

  const floatingTasks = outstandingTasks
    .filter((task) => !task.pinnedDate)
    .sort(scheduleOrderComparator);

  const allocationQueue = [...pinnedTasks, ...floatingTasks];

  allocationQueue.forEach((task) => {
    const manualConsumed = manualMinutes.get(task.id) ?? 0;
    let remaining = clampRemaining((task.durationMinutes ?? 0) - manualConsumed);
    if (remaining <= 0) {
      return;
    }

    const dueDate = task.dueDate ? startOfDay(toDate(task.dueDate)) : null;
    const startDate = task.pinnedDate ? parseDayKey(task.pinnedDate) : today;
    let currentDate = startDate < today ? today : startDate;
    let nextSequence = task.parts?.length ?? 0;
    const generatedParts: TaskPart[] = [];
    let iterations = 0;

    while (remaining > 0 && (currentDate <= horizonEnd || iterations < MIN_ITERATION_BUFFER)) {
      if (iterations > horizonDays + MIN_ITERATION_BUFFER) {
        break;
      }

      const dayKey = formatDayKey(currentDate);
      const entry = ensureDayEntry(usage, settings, dayKey);
      const available = entry.total - entry.used;

      if (available > 0) {
        let chunk = Math.min(remaining, available);

        if (chunk < settings.minChunkMinutes && remaining > settings.minChunkMinutes) {
          // Skip tiny leftovers until we absolutely must schedule them.
          currentDate = addDays(currentDate, 1);
          iterations += 1;
          continue;
        }

        if (remaining <= settings.minChunkMinutes && available >= remaining) {
          chunk = remaining;
        }

        if (chunk > 0) {
          const part: TaskPart = {
            id: `${task.id}:auto:${nextSequence + 1}`,
            taskId: task.id,
            sequence: nextSequence,
            plannedDate: dayKey,
            durationMinutes: chunk,
            isPinned: Boolean(task.pinnedDate && dayKey === task.pinnedDate),
            isAutoGenerated: true,
          };

          generatedParts.push(part);
          entry.used += chunk;
          entry.remaining = Math.max(0, entry.total - entry.used);
          remaining -= chunk;
          nextSequence += 1;
        }
      }

      currentDate = addDays(currentDate, 1);
      iterations += 1;
      if (dueDate && currentDate > horizonEnd && currentDate > dueDate && remaining > 0) {
        break;
      }
    }

    if (generatedParts.length) {
      const combined = [...(task.parts ?? []), ...generatedParts];
      combined.sort((a, b) => a.sequence - b.sequence);
      task.parts = combined;
      task.plannedDate = findEarliestPartDate(combined);
    } else if (task.parts?.length) {
      task.plannedDate = findEarliestPartDate(task.parts);
    } else {
      task.plannedDate = null;
    }
  });

  sanitizedTasks.forEach((task) => {
    if (!task.parts?.length) {
      task.plannedDate = null;
      return;
    }

    task.plannedDate = findEarliestPartDate(task.parts);
  });

  Object.entries(usage).forEach(([, entry]) => {
    entry.remaining = Math.max(0, entry.total - entry.used);
  });

  return {
    tasks: sanitizedTasks,
    capacityUsage: usage,
  };
};

export type AutoPlan = typeof autoPlan;
